@page "/"
@using InCaseIForgetMyCrochet
@using InCaseIForgetMyCrochet.Components.StitchEditor
@using InCaseIForgetMyCrochet.Models
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Components.Web
@inject PatternDbContext Context

@using ToolbarParams = (int? amount, InCaseIForgetMyCrochet.Models.StitchTypeAbbreviation? type);

@rendermode InteractiveServer

<div class="container d-flex flex-column gap-5">
    <h1>Home</h1>
    <div class="d-flex gap-5">
        <ul class="list-group">
            @if (Patterns != null)
            {
                @foreach (var pattern in Patterns)
                {
                    <li class="list-group-item" style="width:15vw;">
                        <button class="btn btn-primary w-100" @onclick="@(() => SelectPattern(pattern))">
                            <h4>@pattern.Name</h4>
                        </button>
                    </li>
                }
                <button class="btn btn-primary w-100" @onclick="NewPattern">
                    <h4>New Pattern</h4>
                </button>
            }
        </ul>
        @if (Pattern != null)
        {
            <EditForm id="stitch-editor" class="container h-100" Model="@Pattern">
                <StitchToolbar Pattern="@Pattern"
                    Refresh="@((ToolbarParams Params) => Refresh((Params.amount,Params.type)))" StitchAmount="@stitchAmount"
                    StitchType="@stitchType" />
                <div class="d-flex">
                    <button class="my-3 py-2 w-100" @onclick="AddRow">
                        Add Row
                    </button>
                    <div>
                        <button class="my-3 py-2 w-100" @onclick="MirrorPatternUp">
                            Mirror Pattern Up ⬆️
                        </button>
                        <button class="my-3 py-2 w-100" @onclick="MirrorPatternDown">
                            Mirror Pattern Down ⬇️
                        </button>
                    </div>
                </div>
                <StitchViewer Pattern="@Pattern" Refresh="Refresh" StitchAmount="@stitchAmount" StitchType="@stitchType" />
            </EditForm>
        }
    </div>
</div>

@code {
    Pattern? Pattern { get; set; }
    List<Pattern>? Patterns { get; set; }
    int stitchAmount { get; set; } = 1;
    StitchTypeAbbreviation stitchType { get; set; }

    protected override async Task OnInitializedAsync()
    {
        Patterns = await Context.Patterns
        .AsTracking()
        .Include(p => p.Rows)
        .ThenInclude(r => r.Instructions)
        .ToListAsync();
    }

    private void NewPattern()
    {
        Pattern = new Pattern();
    }
    private void Refresh()
    => Refresh(new());
    private void Refresh(ToolbarParams Params)
    {
        var (stitchAmount, stitchType) = Params;

        if (stitchAmount.HasValue)
        {
            this.stitchAmount = stitchAmount.Value;
        }
        if (stitchType.HasValue)
        {
            this.stitchType = stitchType.Value;
        }
        StateHasChanged();
    }
    private void SelectPattern(Pattern pattern)
    {
        Pattern = pattern;
    }

    private async Task AddRow()
    {
        if (Pattern is null) return;
        if (Pattern.Rows is null)
        {
            Pattern.Rows = new List<Row>();
        }
        if (Pattern.Rows.Count == 0)
        {
            Pattern.Rows.Add(new Row());
        }
        else
        {
            Pattern.Rows = [new Row(), .. Pattern.Rows.Select(r => r.Clone())];
        }
        await Pattern.SaveChangesAsync(Context);
    }
    private async Task MirrorPatternUp()
    {
        if (Pattern is null) return;

        var normalRows = Pattern.Rows
        .Select(r => r.Clone())
        .ToList();

        var reversedRows = Pattern.Rows
        .Select(r => r.Clone())
        .Reverse()
        .ToList();
        var newRows = new List<Row>();
        newRows.AddRange(reversedRows);
        newRows.AddRange(normalRows);

        Pattern.Rows = newRows;

        await Pattern.SaveChangesAsync(Context);
    }
    private async Task MirrorPatternDown()
    {
        if (Pattern is null) return;

        var reversedRows = Pattern.Rows
        .Select(r => r.Clone())
        .Reverse()
        .ToList();

        Pattern.Rows.AddRange(reversedRows);

        await Pattern.SaveChangesAsync(Context);
    }
}

<style>
    form {

        .btn,
        button {
            border-radius: 10rem;
            display: flex;
            place-content: center;
            place-items: center;
            place-self: center;
        }

        input:last-child {
            border-top-right-radius: 10rem;
            border-bottom-right-radius: 10rem;
        }

        label:first-child {
            border-top-left-radius: 10rem;
            border-bottom-left-radius: 10rem;
        }

        label:last-child {
            border-top-right-radius: 10rem;
            border-bottom-right-radius: 10rem;
        }

        #add-single-toolbar {
            display: flex;
            flex: 1 1 auto;

            & * {
                display: flex;
                flex: 1 1 auto;
            }
        }

        #add-multiple-toolbar {
            display: flex;
            flex: 1 1 auto;

            & * {
                display: flex;
                flex: 1 1 auto;
            }
        }

        * {
            margin: 0;
            padding: 0;
        }

        table {
            display: flex;
            flex: 1 1 auto;
            flex-direction: column;
        }

        tr {
            border-bottom: 1px solid black;
            display: flex;
            flex: 1 1 auto;
            flex-direction: row;
        }

        ul {
            display: flex;
            flex: 1 1 auto;
            flex-direction: row;
            margin: 0;
            padding: 0;
        }

        td {
            display: flex;
            flex: 1 1 auto;
            flex-direction: column;
            margin: auto !important;

            & button {
                padding: 0.3rem 0.6rem;
            }
        }
    }
</style>